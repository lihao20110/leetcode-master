````Go
```Go
//单调栈法：
func largestRectangleArea(heights []int) int {
	// 数组头部加入元素0 数组尾部加入元素0 匿名函数、闭包
	getHeight := func(i int) int {
		if i == 0 || i == len(heights)+1 {
			return 0
		}
		return heights[i-1]
	}
	stack := make([]int, 0)
	stack = append(stack, 0)
	res := 0
	// 第一个元素已经入栈，从下表1开始
	for i := 1; i < len(heights)+2; i++ {
		if getHeight(i) > getHeight(stack[len(stack)-1]) {
			stack = append(stack, i)
		} else if getHeight(i) == getHeight(stack[len(stack)-1]) {
			stack = stack[:len(stack)-1] // 这个可以加，可以不加，效果一样，思路不同
			stack = append(stack, i)
		} else {
			for len(stack) > 0 && getHeight(i) < getHeight(stack[len(stack)-1]) {
				mid := stack[len(stack)-1]
				stack = stack[:len(stack)-1]
				if len(stack) > 0 {
					l := stack[len(stack)-1]
					w := i - l - 1
					h := getHeight(mid)
					if res < w*h {
						res = w * h
					}
				}
			}
			stack = append(stack, i)
		}
	}
	return res
}
//双指针解法 超出时间限制
func largestRectangleArea(heights []int) int {
	res := 0
	for i := 0; i < len(heights); i++ {
		left := i
		right := i
		for ; left >= 0; left-- {
			if heights[left] < heights[i] {
				break
			}
		}
		for ; right < len(heights); right++ {
			if heights[right] < heights[i] {
				break
			}
		}
		w := right - left - 1
		h := heights[i]
		if res < w*h {
			res = w * h
		}
	}
	return res
}
//动态规划：
func largestRectangleArea(heights []int) int {
	minLeftIndex := make([]int, len(heights))
	minRightIndex := make([]int, len(heights))
	// 记录每个柱子 左边第一个小于该柱子的下标
	minLeftIndex[0] = -1
	// 注意这里初始化，防止下面死循环
	for i := 1; i < len(heights); i++ {
		t := i - 1
		for t >= 0 && heights[t] >= heights[i] {
			t = minLeftIndex[t]
		}
		minLeftIndex[i] = t
	}
	// 记录每个柱子 右边第一个小于该柱子的下标
	minRightIndex[len(heights)-1] = len(heights)
	// 注意这里初始化，防止下面死循环
	for i := len(heights) - 2; i >= 0; i-- {
		t := i + 1
		for t < len(heights) && heights[t] >= heights[i] {
			t = minRightIndex[t]
		}
		minRightIndex[i] = t
	}
	res := 0
	for i := range heights {
		sum := heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1)
		if res < sum {
			res = sum
		}
	}
	return res
}
```
````